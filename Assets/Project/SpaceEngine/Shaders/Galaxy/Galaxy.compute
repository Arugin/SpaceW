// NOTE : Based on https://dexyfex.com/2016/09/09/galaxy-rendering-revisited/

Texture2D MaterialTable;
SamplerState sampler_point_repeat_MaterialTable;

float4 GetMaterial(float value)
{
	return MaterialTable.SampleLevel(sampler_point_repeat_MaterialTable, float2(value, 0.0), 0);
}

#define COMPUTE_SHADER

#include "Galaxy.cginc"

#pragma kernel Core

GalaxyStar GenerateStar(uint id)
{
	float4 rnd = Random4(id) + float4(0.0, Randomize);

	float size = radius * 0.025 * (rnd.w * rnd.w + 0.5);					// Randomize the particle size...
	
	float eRadius = rnd.x * ellipseRadius;									// Size of the galactic ellipse...
	float theta = rnd.y * M_PI2;											// Angle around the ellipse...
	float height = rnd.z;													// Distance from the galactic plane...
	
	float2 pxy = float2(cos(theta), sin(theta)) * radius * eRadius;			// Make a circle...
	float3 pos = float3(pxy.x, height * depth * 0.1, pxy.y);				// Place the circle...
	float3 galaxyAxis = float3(0.0, 1.0, 0.0);								// Rotation axis for ellipses...
	float3 armAxis = float3(0.0, 1.0, 0.0);

	galaxyAxis.xz += eRadius * warp1;										// Warp the rotation axis...
	
	float angle = saturate(eRadius - barSize) * spiralRotation;				// Angle to rotate the ellipse...
	
	galaxyAxis.xz += eRadius * angle * warp2;								// Warp the axis by the angle amount...
	
	float4 q = qaxang(galaxyAxis, angle);									// Positive orientation...
	float4 qi = qaxang(galaxyAxis, -angle);									// Negative orientation...
	float4 qa = qaxang(armAxis, passRotation);								// Arm orientation...

	pos = mulvq(pos, q);

	pos.x *= inverseEccentricity;											// Turn the circle into an ellipse...

	// TODO : Vector math instead of per-component...
	pos.x += eRadius * radius * offsetX;									// Offset ellipses to make some asymmetry...
	pos.y += eRadius * radius * offsetY;									// Offset ellipses to make some asymmetry...
	pos.z += eRadius * radius * offsetZ;									// Offset ellipses to make some asymmetry...

	pos = mulvq(pos, qi);													// Rotate the ellipse to where it should be to make spirals...
	pos = mulvq(pos, qa);													// Fake-arm rotation...

	float distribution = length(pos) / radius * M_PHI * (size / 2.0);
	float temperature = distribution * rnd.w;								// Fake temperature distribution...

	GalaxyStar star;
	star.position = pos;
	star.color = GetMaterial(temperature);
	star.size = size;
	star.temperature = distribution;

	return star;
}

RWStructuredBuffer<GalaxyStar> output;

[numthreads(1024, 1, 1)]
void Core(uint3 gtid : SV_GroupThreadID, uint3 gid : SV_GroupID)
{
	uint id = gid.x * 1024 + gtid.x;
	
	GalaxyStar star = GenerateStar(id);
	
	output[id] = star;
}