// NOTE : Based on https://dexyfex.com/2016/09/09/galaxy-rendering-revisited/

#define COMPUTE_SHADER

#define NUM_THREADS_X 1024
#define NUM_THREADS_Y 1
#define NUM_THREADS_Z 1

#include "Galaxy.cginc"

float3 GenerateParticlePosition(in uint id, in float4 rnd)
{
	float eRadius = rnd.x * ellipseRadius;									// Size of the galactic ellipse...
	float theta = rnd.y * M_PI2;											// Angle around the ellipse...
	float height = rnd.z;													// Distance from the galactic plane...
	
	float2 pxy = float2(cos(theta), sin(theta)) * radius * eRadius;			// Make a circle...
	float3 pos = float3(pxy.x, height * depth * 0.1, pxy.y);				// Place the circle...
	float3 galaxyAxis = float3(0.0, 1.0, 0.0);								// Rotation axis for ellipses...
	float3 armAxis = float3(0.0, 1.0, 0.0);

	galaxyAxis.xz += eRadius * warp1;										// Warp the rotation axis...
	
	float angle = saturate(eRadius - barSize) * spiralRotation;				// Angle to rotate the ellipse...
	
	galaxyAxis.xz += eRadius * angle * warp2;								// Warp the axis by the angle amount...
	
	float4 q = qaxang(galaxyAxis, angle);									// Positive orientation...
	float4 qi = qaxang(galaxyAxis, -angle);									// Negative orientation...
	float4 qa = qaxang(armAxis, passRotation);								// Arm orientation...

	pos = mulvq(pos, q);

	pos.x *= inverseEccentricity;											// Turn the circle into an ellipse...

	// TODO : Vector math instead of per-component...
	pos.x += eRadius * radius * offsetX;									// Offset ellipses to make some asymmetry...
	pos.y += eRadius * radius * offsetY;									// Offset ellipses to make some asymmetry...
	pos.z += eRadius * radius * offsetZ;									// Offset ellipses to make some asymmetry...

	pos = mulvq(pos, qi);													// Rotate the ellipse to where it should be to make spirals...
	pos = mulvq(pos, qa);													// Fake-arm rotation...

	float3 rp = Random3(id) / 2.0;

	// NOTE : Branches...
	return id % 2 == 0 ? pos + rp : pos - rp;
}

float GenerateParticleSize(in float4 rnd)
{
	return radius * 0.025 * (rnd.w * rnd.w + 0.5);							// Randomize the particle size...
}

float GenerateParticleDistribution(in float3 position, in float size, in float scale)
{
	return (length(position) / scale) / radius * M_PHI * (size / 2.0);		// Randomize distribution on position...
}

float GenerateParticleTemperature(in float4 rnd, in float distribution)
{
	temperatureMin /= 10000;
	temperatureMax /= 10000;
	temperatureShift /= 10000;

	float temperature = distribution * (rnd.w * M_PHI);

	return ((temperature + temperatureShift) - temperatureMin) / temperatureMax;
}

GalaxyStar GenerateParticle(uint id, float pertrub, float4 rnd)
{
	float3 position = GenerateParticlePosition(id, rnd);
	float size = GenerateParticleSize(rnd);
	float distribution = GenerateParticleDistribution(position, size, pertrub);
	float temperature = GenerateParticleTemperature(rnd, distribution);
	float4 color = GetMaterial(temperature);

	GalaxyStar star;
	star.position = position;
	star.color = color;
	star.size = size;
	star.temperature = temperature;

	return star;
}

#pragma kernel Stars

RWStructuredBuffer<GalaxyStar> stars_output;

[numthreads(NUM_THREADS_X, NUM_THREADS_Y, NUM_THREADS_Z)]
void Stars(uint3 groupThreadID : SV_GroupThreadID, 
		   uint3 groupID : SV_GroupID, 
		   uint3 dispatchThreadID : SV_DispatchThreadID, 
		   uint groupIndex : SV_GroupIndex)
{
	uint id = groupID.x * NUM_THREADS_X + groupThreadID.x;
	
	float4 rnd = frac(Random4(id) + float4(0.0, randomParams1));

	GalaxyStar star = GenerateParticle(id, rnd.x, rnd);

	stars_output[id] = star;
}

#pragma kernel Dust

RWStructuredBuffer<GalaxyStar> dust_output;

[numthreads(NUM_THREADS_X, NUM_THREADS_Y, NUM_THREADS_Z)]
void Dust(uint3 groupThreadID : SV_GroupThreadID, 
		  uint3 groupID : SV_GroupID, 
		  uint3 dispatchThreadID : SV_DispatchThreadID, 
		  uint groupIndex : SV_GroupIndex)
{
	uint id = groupID.x * NUM_THREADS_X + groupThreadID.x;
	
	float4 rnd = Random4(id) + float4(0.0, randomParams1);

	GalaxyStar star = GenerateParticle(id, 1.0, rnd);
	
	dust_output[id] = star;
}