// NOTE : Based on https://dexyfex.com/2016/09/09/galaxy-rendering-revisited/

#define COMPUTE_SHADER

#define THREADS_X 1024
#define THREADS_Y 1
#define THREADS_Z 1

#include "Galaxy.cginc"

GalaxyStar GenerateStar(uint id, float pertrub, float4 rnd)
{
	float size = radius * 0.025 * (rnd.w * rnd.w + 0.5);					// Randomize the particle size...
	float halfSize = size / 2.0;
	
	float eRadius = rnd.x * ellipseRadius;									// Size of the galactic ellipse...
	float theta = rnd.y * M_PI2;											// Angle around the ellipse...
	float height = rnd.z;													// Distance from the galactic plane...
	
	float2 pxy = float2(cos(theta), sin(theta)) * radius * eRadius;			// Make a circle...
	float3 pos = float3(pxy.x, height * depth * 0.1, pxy.y);				// Place the circle...
	float3 galaxyAxis = float3(0.0, 1.0, 0.0);								// Rotation axis for ellipses...
	float3 armAxis = float3(0.0, 1.0, 0.0);

	galaxyAxis.xz += eRadius * warp1;										// Warp the rotation axis...
	
	float angle = saturate(eRadius - barSize) * spiralRotation;				// Angle to rotate the ellipse...
	
	galaxyAxis.xz += eRadius * angle * warp2;								// Warp the axis by the angle amount...
	
	float4 q = qaxang(galaxyAxis, angle);									// Positive orientation...
	float4 qi = qaxang(galaxyAxis, -angle);									// Negative orientation...
	float4 qa = qaxang(armAxis, passRotation);								// Arm orientation...

	pos = mulvq(pos, q);

	pos.x *= inverseEccentricity;											// Turn the circle into an ellipse...

	// TODO : Vector math instead of per-component...
	pos.x += eRadius * radius * offsetX;									// Offset ellipses to make some asymmetry...
	pos.y += eRadius * radius * offsetY;									// Offset ellipses to make some asymmetry...
	pos.z += eRadius * radius * offsetZ;									// Offset ellipses to make some asymmetry...

	pos = mulvq(pos, qi);													// Rotate the ellipse to where it should be to make spirals...
	pos = mulvq(pos, qa);													// Fake-arm rotation...

	float distribution = (length(pos) / pertrub) / radius * M_PHI * halfSize;
	float temperature = ((distribution * (rnd.w * M_PHI)) - 0.08f) / 2.92f;	// Fake temperature distribution...

	GalaxyStar star;
	star.position = pos;
	star.color = GetMaterial(temperature);
	star.size = size;
	star.temperature = temperature;

	return star;
}

#pragma kernel Stars

RWStructuredBuffer<GalaxyStar> stars_output;

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void Stars(uint3 groupThreadID : SV_GroupThreadID, 
		   uint3 groupID : SV_GroupID, 
		   uint3 dispatchThreadID : SV_DispatchThreadID, 
		   uint groupIndex : SV_GroupIndex)
{
	uint id = groupID.x * THREADS_X + groupThreadID.x;
	
	float4 rnd = frac(Random4(id) + float4(0.0, randomParams1));

	GalaxyStar star = GenerateStar(id, rnd.x, rnd);

	stars_output[id] = star;
}

#pragma kernel Dust

RWStructuredBuffer<GalaxyStar> dust_output;

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void Dust(uint3 groupThreadID : SV_GroupThreadID, 
		  uint3 groupID : SV_GroupID, 
		  uint3 dispatchThreadID : SV_DispatchThreadID, 
		  uint groupIndex : SV_GroupIndex)
{
	uint id = groupID.x * THREADS_X + groupThreadID.x;
	
	float4 rnd = Random4(id) + float4(0.0, randomParams1);

	GalaxyStar star = GenerateStar(id, 1.0, rnd);
	
	dust_output[id] = star;
}